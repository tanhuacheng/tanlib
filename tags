!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARRAY_LENGTH	test/tmemfill.c	7;"	d	file:
BUFFER_SIZE	test/tqueue-link.c	8;"	d	file:
BUFFER_SIZE	test/tqueue-list-vs-link.c	11;"	d	file:
BUFFER_SIZE	test/tqueue-list.c	8;"	d	file:
CC	Makefile	/^CC 		= gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS 	= -g -Wall --std gnu99 -I .\/include\/$/;"	m
DIVMOD_H_	include/divmod.h	24;"	d
INDEXOF	include/typedefs.h	16;"	d
JITTER_H_	include/jitter.h	22;"	d
JITTER_PARAM_MUL_HIG	include/jitter.h	35;"	d
JITTER_PARAM_MUL_LOW	include/jitter.h	37;"	d
JITTER_PARAM_MUL_MAX	include/jitter.h	34;"	d
JITTER_PARAM_MUL_MET	include/jitter.h	38;"	d
JITTER_PARAM_MUL_STD	include/jitter.h	36;"	d
JITTER_READY	src/jitter.c	/^        JITTER_READY,   $/;"	e	enum:jitter::__anon2	file:
JITTER_STANDBY	src/jitter.c	/^        JITTER_STANDBY,$/;"	e	enum:jitter::__anon2	file:
LDFLAGS	Makefile	/^LDFLAGS = -pthread$/;"	m
LENGTH_LARGE	test/tsort.c	83;"	d	file:
LENGTH_LESS	test/tsort.c	82;"	d	file:
MEMBOF	test/tsort.c	14;"	d	file:
MEMFILL_H_	include/memfill.h	22;"	d
MIN	src/memfill.c	16;"	d	file:
NDEBUG	test/tsort.c	3;"	d	file:
QUEUE_ARRAY_H_	include/queue-array.h	22;"	d
QUEUE_LENGTH	test/tqueue-array.c	7;"	d	file:
QUEUE_LINK_H_	include/queue-link.h	24;"	d
QUEUE_LIST_H_	include/queue-list.h	23;"	d
TIMES	test/tqueue-list-vs-link.c	12;"	d	file:
VPATH	Makefile	/^VPATH 	= .\/src\/ : .\/test\/ : .\/include\/$/;"	m
__anon3::size	src/queue-link.c	/^    uint32_t size;$/;"	m	struct:__anon3	file:	access:public
__anon3::top	src/queue-link.c	/^    queue_link_node_t* top;$/;"	m	struct:__anon3	file:	access:public
__anon4::__anon5::buff	include/queue-array.h	/^        void* buff; \/* 指向一块连续的内存区域 *\/$/;"	m	struct:__anon4::__anon5	access:public
__anon4::__anon5::mlen	include/queue-array.h	/^        uint32_t mlen; \/* buff最多可以存放的数据单元数 *\/$/;"	m	struct:__anon4::__anon5	access:public
__anon4::__anon5::size	include/queue-array.h	/^        size_t size; \/* 数据单元占用字节数 *\/$/;"	m	struct:__anon4::__anon5	access:public
__anon4::data	include/queue-array.h	/^    } data;$/;"	m	struct:__anon4	typeref:struct:__anon4::__anon5	access:public
__anon4::front	include/queue-array.h	/^    volatile uint32_t front;$/;"	m	struct:__anon4	access:public
__anon4::rear	include/queue-array.h	/^    volatile uint32_t rear;$/;"	m	struct:__anon4	access:public
__merge_sort	src/merge_sort.c	/^static void __merge_sort (struct aux_data* aux, size_t start, size_t end)$/;"	f	file:	signature:(struct aux_data* aux, size_t start, size_t end)
array	test/tmemfill.c	/^static struct data array[ARRAY_LENGTH] = {{0}};$/;"	v	typeref:struct:data	file:
array	test/tqueue-array.c	/^static int array[QUEUE_LENGTH];$/;"	v	file:
aux_data	src/merge_sort.c	/^struct aux_data {$/;"	s	file:
aux_data::base	src/merge_sort.c	/^    void* base;$/;"	m	struct:aux_data	file:	access:public
aux_data::compare	src/merge_sort.c	/^    compare_t compare;$/;"	m	struct:aux_data	file:	access:public
aux_data::size	src/merge_sort.c	/^    size_t size;$/;"	m	struct:aux_data	file:	access:public
aux_data::temp	src/merge_sort.c	/^    void* temp;$/;"	m	struct:aux_data	file:	access:public
base	src/merge_sort.c	/^    void* base;$/;"	m	struct:aux_data	file:	access:public
bsnode	src/bstree.c	/^struct bsnode {$/;"	s	file:
bsnode::data	src/bstree.c	/^    void* data;$/;"	m	struct:bsnode	file:	access:public
bsnode::left	src/bstree.c	/^    struct bsnode* left;$/;"	m	struct:bsnode	typeref:struct:bsnode::bsnode	file:	access:public
bsnode::p	src/bstree.c	/^    struct bsnode* p;$/;"	m	struct:bsnode	typeref:struct:bsnode::bsnode	file:	access:public
bsnode::right	src/bstree.c	/^    struct bsnode* right;$/;"	m	struct:bsnode	typeref:struct:bsnode::bsnode	file:	access:public
bsnode_delete	src/bstree.c	/^static void bsnode_delete (struct bsnode** root, struct bsnode* node)$/;"	f	file:	signature:(struct bsnode** root, struct bsnode* node)
bsnode_destroy	src/bstree.c	/^static void bsnode_destroy (struct bsnode* node)$/;"	f	file:	signature:(struct bsnode* node)
bsnode_insert	src/bstree.c	/^static void bsnode_insert (struct bsnode** root, struct bsnode* node, compare_t compare)$/;"	f	file:	signature:(struct bsnode** root, struct bsnode* node, compare_t compare)
bsnode_max	src/bstree.c	/^static struct bsnode* bsnode_max (struct bsnode* node)$/;"	f	file:	signature:(struct bsnode* node)
bsnode_min	src/bstree.c	/^static struct bsnode* bsnode_min (struct bsnode* node)$/;"	f	file:	signature:(struct bsnode* node)
bsnode_search	src/bstree.c	/^static struct bsnode* bsnode_search (struct bsnode* node, const void* data, compare_t compare)$/;"	f	file:	signature:(struct bsnode* node, const void* data, compare_t compare)
bsnode_transplant	src/bstree.c	/^static void bsnode_transplant (struct bsnode** root, struct bsnode* u, struct bsnode* v)$/;"	f	file:	signature:(struct bsnode** root, struct bsnode* u, struct bsnode* v)
bsnode_walk	src/bstree.c	/^static void bsnode_walk (const struct bsnode* node, void (*callback) (const void* data))$/;"	f	file:	signature:(const struct bsnode* node, void (*callback) (const void* data))
bstree	src/bstree.c	/^struct bstree {$/;"	s	file:
bstree	test/tbstree.c	/^static struct bstree* bstree;$/;"	v	typeref:struct:bstree	file:
bstree::compare	src/bstree.c	/^    compare_t compare;$/;"	m	struct:bstree	file:	access:public
bstree::mutex	src/bstree.c	/^    pthread_mutex_t mutex;$/;"	m	struct:bstree	file:	access:public
bstree::root	src/bstree.c	/^    struct bsnode *root;$/;"	m	struct:bstree	typeref:struct:bstree::bsnode	file:	access:public
bstree::size	src/bstree.c	/^    size_t size;$/;"	m	struct:bstree	file:	access:public
bstree_create	include/bstree.h	/^struct bstree* bstree_create (size_t size, compare_t compare);$/;"	p	signature:(size_t size, compare_t compare)
bstree_create	src/bstree.c	/^struct bstree* bstree_create (size_t size, compare_t compare)$/;"	f	signature:(size_t size, compare_t compare)
bstree_delete	include/bstree.h	/^int_fast32_t bstree_delete (struct bstree* bstree, void* data);$/;"	p	signature:(struct bstree* bstree, void* data)
bstree_delete	src/bstree.c	/^int_fast32_t bstree_delete (struct bstree* bstree, void* data)$/;"	f	signature:(struct bstree* bstree, void* data)
bstree_destroy	include/bstree.h	/^void bstree_destroy (struct bstree* bstree);$/;"	p	signature:(struct bstree* bstree)
bstree_destroy	src/bstree.c	/^void bstree_destroy (struct bstree* bstree)$/;"	f	signature:(struct bstree* bstree)
bstree_insert	include/bstree.h	/^int_fast32_t bstree_insert (struct bstree* bstree, const void* data);$/;"	p	signature:(struct bstree* bstree, const void* data)
bstree_insert	src/bstree.c	/^int_fast32_t bstree_insert (struct bstree* bstree, const void* data)$/;"	f	signature:(struct bstree* bstree, const void* data)
bstree_max	include/bstree.h	/^int_fast32_t bstree_max (struct bstree* bstree, void* data);$/;"	p	signature:(struct bstree* bstree, void* data)
bstree_max	src/bstree.c	/^int_fast32_t bstree_max (struct bstree* bstree, void* data)$/;"	f	signature:(struct bstree* bstree, void* data)
bstree_min	include/bstree.h	/^int_fast32_t bstree_min (struct bstree* bstree, void* data);$/;"	p	signature:(struct bstree* bstree, void* data)
bstree_min	src/bstree.c	/^int_fast32_t bstree_min (struct bstree* bstree, void* data)$/;"	f	signature:(struct bstree* bstree, void* data)
bstree_search	include/bstree.h	/^int_fast32_t bstree_search (struct bstree* bstree, void* data);$/;"	p	signature:(struct bstree* bstree, void* data)
bstree_search	src/bstree.c	/^int_fast32_t bstree_search (struct bstree* bstree, void* data)$/;"	f	signature:(struct bstree* bstree, void* data)
bstree_walk	include/bstree.h	/^int_fast32_t bstree_walk (struct bstree* bstree, void (*callback) (const void* data));$/;"	p	signature:(struct bstree* bstree, void (*callback) (const void* data))
bstree_walk	src/bstree.c	/^int_fast32_t bstree_walk (struct bstree* bstree, void (*callback) (const void* data))$/;"	f	signature:(struct bstree* bstree, void (*callback) (const void* data))
buff	include/queue-array.h	/^        void* buff; \/* 指向一块连续的内存区域 *\/$/;"	m	struct:__anon4::__anon5	access:public
buff	src/queue-link.c	/^    void* buff;$/;"	m	struct:queue_link_node	file:	access:public
buff	src/queue-list.c	/^    void* buff;$/;"	m	struct:queue_list_node	file:	access:public
buff	test/tqueue-list-vs-link.c	/^static int16_t buff[BUFFER_SIZE];$/;"	v	file:
buffer	test/tqueue-link.c	/^static int16_t buffer[BUFFER_SIZE];$/;"	v	file:
buffer	test/tqueue-list.c	/^static int16_t buffer[BUFFER_SIZE];$/;"	v	file:
callback	test/tbstree.c	/^static void callback (const void* data)$/;"	f	file:	signature:(const void* data)
cnt_drop	src/jitter.c	/^    uint32_t cnt_drop;$/;"	m	struct:jitter	file:	access:public
cnt_insert	src/jitter.c	/^    uint32_t cnt_insert;$/;"	m	struct:jitter	file:	access:public
compare	src/bstree.c	/^    compare_t compare;$/;"	m	struct:bstree	file:	access:public
compare	src/merge_sort.c	/^    compare_t compare;$/;"	m	struct:aux_data	file:	access:public
compare	test/tbstree.c	/^static int_fast32_t compare (const void* data1, const void* data2)$/;"	f	file:	signature:(const void* data1, const void* data2)
compare	test/tsort.c	/^static int compare (const void* data1, const void* data2)$/;"	f	file:	signature:(const void* data1, const void* data2)
compare_t	include/typedefs.h	/^typedef int (*compare_t) (const void*, const void*);$/;"	t
cond	src/queue-link.c	/^    pthread_cond_t cond;$/;"	m	struct:queue_link	file:	access:public
cond	src/queue-list.c	/^    pthread_cond_t cond;$/;"	m	struct:queue_list	file:	access:public
data	include/queue-array.h	/^    } data;$/;"	m	struct:__anon4	typeref:struct:__anon4::__anon5	access:public
data	src/bstree.c	/^    void* data;$/;"	m	struct:bsnode	file:	access:public
data	test/tmemfill.c	/^struct data {$/;"	s	file:
data::x	test/tmemfill.c	/^    int x;$/;"	m	struct:data	file:	access:public
data::y	test/tmemfill.c	/^    int y;$/;"	m	struct:data	file:	access:public
divmod	include/divmod.h	/^static inline uint32_t divmod (uint32_t x, uint32_t y, uint32_t* z)$/;"	f	signature:(uint32_t x, uint32_t y, uint32_t* z)
foreach	include/foreach.h	20;"	d
front	include/queue-array.h	/^    volatile uint32_t front;$/;"	m	struct:__anon4	access:public
head	src/queue-link.c	/^    queue_link_node_t* head;$/;"	m	struct:queue_link	file:	access:public
head	src/queue-list.c	/^    queue_list_node_t* head;$/;"	m	struct:queue_list	file:	access:public
hig	src/jitter.c	/^        uint32_t hig;$/;"	m	struct:jitter::__anon1	file:	access:public
idle	src/queue-link.c	/^    stack_idle_t idle;$/;"	m	struct:queue_link	file:	access:public
incmod	include/divmod.h	/^static inline uint32_t incmod (uint32_t inc, const uint32_t mod)$/;"	f	signature:(uint32_t inc, const uint32_t mod)
insert_sort	include/sort.h	/^int insert_sort (void* base, size_t nmemb, size_t size, compare_t compare);$/;"	p	signature:(void* base, size_t nmemb, size_t size, compare_t compare)
insert_sort	src/insert_sort.c	/^int insert_sort (void* base, size_t nmemb, size_t size, compare_t compare)$/;"	f	signature:(void* base, size_t nmemb, size_t size, compare_t compare)
jitter	src/jitter.c	/^struct jitter {$/;"	s	file:
jitter	test/tjitter.c	/^jitter_t *jitter;$/;"	v
jitter::JITTER_READY	src/jitter.c	/^        JITTER_READY,   $/;"	e	enum:jitter::__anon2	file:
jitter::JITTER_STANDBY	src/jitter.c	/^        JITTER_STANDBY,$/;"	e	enum:jitter::__anon2	file:
jitter::__anon1::hig	src/jitter.c	/^        uint32_t hig;$/;"	m	struct:jitter::__anon1	file:	access:public
jitter::__anon1::low	src/jitter.c	/^        uint32_t low;$/;"	m	struct:jitter::__anon1	file:	access:public
jitter::__anon1::max	src/jitter.c	/^        uint32_t max;$/;"	m	struct:jitter::__anon1	file:	access:public
jitter::__anon1::met	src/jitter.c	/^        uint32_t met;$/;"	m	struct:jitter::__anon1	file:	access:public
jitter::__anon1::size	src/jitter.c	/^        size_t size;$/;"	m	struct:jitter::__anon1	file:	access:public
jitter::__anon1::std	src/jitter.c	/^        uint32_t std;$/;"	m	struct:jitter::__anon1	file:	access:public
jitter::__anon1::unit	src/jitter.c	/^        uint32_t unit;$/;"	m	struct:jitter::__anon1	file:	access:public
jitter::cnt_drop	src/jitter.c	/^    uint32_t cnt_drop;$/;"	m	struct:jitter	file:	access:public
jitter::cnt_insert	src/jitter.c	/^    uint32_t cnt_insert;$/;"	m	struct:jitter	file:	access:public
jitter::lock	src/jitter.c	/^    pthread_mutex_t lock;$/;"	m	struct:jitter	file:	access:public
jitter::param	src/jitter.c	/^    } param;$/;"	m	struct:jitter	typeref:struct:jitter::__anon1	file:	access:public
jitter::queue	src/jitter.c	/^    queue_array_t queue;$/;"	m	struct:jitter	file:	access:public
jitter::state	src/jitter.c	/^    } state;$/;"	m	struct:jitter	typeref:enum:jitter::__anon2	file:	access:public
jitter_create	include/jitter.h	/^jitter_t* jitter_create (const size_t size, const int32_t unit);$/;"	p	signature:(const size_t size, const int32_t unit)
jitter_create	src/jitter.c	/^jitter_t* jitter_create (const size_t size, const int32_t unit)$/;"	f	signature:(const size_t size, const int32_t unit)
jitter_destroy	include/jitter.h	/^int32_t jitter_destroy (jitter_t* jitter);$/;"	p	signature:(jitter_t* jitter)
jitter_destroy	src/jitter.c	/^int32_t jitter_destroy (jitter_t* jitter)$/;"	f	signature:(jitter_t* jitter)
jitter_flush	include/jitter.h	/^int32_t jitter_flush (jitter_t* jitter);$/;"	p	signature:(jitter_t* jitter)
jitter_flush	src/jitter.c	/^int32_t jitter_flush (jitter_t* jitter)$/;"	f	signature:(jitter_t* jitter)
jitter_read	include/jitter.h	/^int32_t jitter_read (jitter_t* jitter, void* buff);$/;"	p	signature:(jitter_t* jitter, void* buff)
jitter_read	src/jitter.c	/^int32_t jitter_read (jitter_t* jitter, void* buff)$/;"	f	signature:(jitter_t* jitter, void* buff)
jitter_t	include/jitter.h	/^typedef struct jitter jitter_t;$/;"	t	typeref:struct:jitter
jitter_write	include/jitter.h	/^int32_t jitter_write (jitter_t* jitter, const void* buff, int32_t length);$/;"	p	signature:(jitter_t* jitter, const void* buff, int32_t length)
jitter_write	src/jitter.c	/^int32_t jitter_write (jitter_t* jitter, const void* buff, int32_t length)$/;"	f	signature:(jitter_t* jitter, const void* buff, int32_t length)
key	test/tbstree.c	/^    uint32_t key;$/;"	m	struct:node	file:	access:public
left	src/bstree.c	/^    struct bsnode* left;$/;"	m	struct:bsnode	typeref:struct:bsnode::bsnode	file:	access:public
lock	src/jitter.c	/^    pthread_mutex_t lock;$/;"	m	struct:jitter	file:	access:public
low	src/jitter.c	/^        uint32_t low;$/;"	m	struct:jitter::__anon1	file:	access:public
main	test/tbstree.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tforeach.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tjitter.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tmemfill.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tqueue-array.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tqueue-link.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tqueue-list-vs-link.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tqueue-list.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
main	test/tsort.c	/^int main (int argc, char* argv[])$/;"	f	signature:(int argc, char* argv[])
max	src/jitter.c	/^        uint32_t max;$/;"	m	struct:jitter::__anon1	file:	access:public
memfill	include/memfill.h	/^void* memfill (void* restrict dstp, size_t dstsize, const void* restrict patp, size_t patsize);$/;"	p	signature:(void* restrict dstp, size_t dstsize, const void* restrict patp, size_t patsize)
memfill	src/memfill.c	/^void* memfill (void* restrict dstp, size_t dstsize, const void* restrict patp, size_t patsize)$/;"	f	signature:(void* restrict dstp, size_t dstsize, const void* restrict patp, size_t patsize)
memfill2	test/tmemfill.c	/^static void* memfill2 (void* restrict dstp, size_t dstsize, const void* restrict patp, size_t patsize)$/;"	f	file:	signature:(void* restrict dstp, size_t dstsize, const void* restrict patp, size_t patsize)
merge	src/merge_sort.c	/^static void merge (struct aux_data* aux, size_t start, size_t middle, size_t end)$/;"	f	file:	signature:(struct aux_data* aux, size_t start, size_t middle, size_t end)
merge_sort	include/sort.h	/^int merge_sort (void* base, size_t nmemb, size_t size, compare_t compare);$/;"	p	signature:(void* base, size_t nmemb, size_t size, compare_t compare)
merge_sort	src/merge_sort.c	/^int merge_sort (void* base, size_t nmemb, size_t size, compare_t compare)$/;"	f	signature:(void* base, size_t nmemb, size_t size, compare_t compare)
met	src/jitter.c	/^        uint32_t met;$/;"	m	struct:jitter::__anon1	file:	access:public
mlen	include/queue-array.h	/^        uint32_t mlen; \/* buff最多可以存放的数据单元数 *\/$/;"	m	struct:__anon4::__anon5	access:public
mutex	src/bstree.c	/^    pthread_mutex_t mutex;$/;"	m	struct:bstree	file:	access:public
mutex	src/queue-link.c	/^    pthread_mutex_t mutex;$/;"	m	struct:queue_link	file:	access:public
mutex	src/queue-list.c	/^    pthread_mutex_t mutex;$/;"	m	struct:queue_list	file:	access:public
next	src/queue-link.c	/^    struct queue_link_node* next;$/;"	m	struct:queue_link_node	typeref:struct:queue_link_node::queue_link_node	file:	access:public
next	src/queue-list.c	/^    struct queue_list_node* next;$/;"	m	struct:queue_list_node	typeref:struct:queue_list_node::queue_list_node	file:	access:public
node	test/tbstree.c	/^struct node {$/;"	s	file:
node::key	test/tbstree.c	/^    uint32_t key;$/;"	m	struct:node	file:	access:public
node::string	test/tbstree.c	/^    char string[32];$/;"	m	struct:node	file:	access:public
p	src/bstree.c	/^    struct bsnode* p;$/;"	m	struct:bsnode	typeref:struct:bsnode::bsnode	file:	access:public
param	src/jitter.c	/^    } param;$/;"	m	struct:jitter	typeref:struct:jitter::__anon1	file:	access:public
q	test/tqueue-array.c	/^static queue_array_t q;$/;"	v	file:
q_link	test/tqueue-list-vs-link.c	/^static queue_link_t* q_link;$/;"	v	file:
q_list	test/tqueue-list-vs-link.c	/^static queue_list_t* q_list;$/;"	v	file:
ql	test/tqueue-link.c	/^static queue_link_t* ql;$/;"	v	file:
ql	test/tqueue-list.c	/^static queue_list_t* ql;$/;"	v	file:
queue	src/jitter.c	/^    queue_array_t queue;$/;"	m	struct:jitter	file:	access:public
queue_array_cal_length	src/queue-array.c	/^static inline uint32_t queue_array_cal_length ($/;"	f	file:	signature:( const uint32_t front, const uint32_t rear, const uint32_t mlen)
queue_array_fill	include/queue-array.h	/^int32_t queue_array_fill (queue_array_t* q, const void* buff, int32_t length);$/;"	p	signature:(queue_array_t* q, const void* buff, int32_t length)
queue_array_fill	src/queue-array.c	/^int32_t queue_array_fill (queue_array_t* q, const void* buff, int32_t length)$/;"	f	signature:(queue_array_t* q, const void* buff, int32_t length)
queue_array_fill_write	src/queue-array.c	/^static int32_t queue_array_fill_write (queue_array_t* q, const void* buff, int32_t length, const uint8_t type)$/;"	f	file:	signature:(queue_array_t* q, const void* buff, int32_t length, const uint8_t type)
queue_array_flush	include/queue-array.h	/^int32_t queue_array_flush (queue_array_t* q);$/;"	p	signature:(queue_array_t* q)
queue_array_flush	src/queue-array.c	/^int32_t queue_array_flush (queue_array_t* q)$/;"	f	signature:(queue_array_t* q)
queue_array_init	include/queue-array.h	/^int32_t queue_array_init (queue_array_t* q, void* buff, const size_t size, const int32_t mlen);$/;"	p	signature:(queue_array_t* q, void* buff, const size_t size, const int32_t mlen)
queue_array_init	src/queue-array.c	/^int32_t queue_array_init (queue_array_t* q, void* buff, const size_t size, const int32_t mlen)$/;"	f	signature:(queue_array_t* q, void* buff, const size_t size, const int32_t mlen)
queue_array_invalid	src/queue-array.c	/^static inline bool queue_array_invalid (const queue_array_t* q)$/;"	f	file:	signature:(const queue_array_t* q)
queue_array_length	include/queue-array.h	/^int32_t queue_array_length (const queue_array_t* q);$/;"	p	signature:(const queue_array_t* q)
queue_array_length	src/queue-array.c	/^int32_t queue_array_length (const queue_array_t* q)$/;"	f	signature:(const queue_array_t* q)
queue_array_read	include/queue-array.h	/^int32_t queue_array_read (queue_array_t* q, void* buff, int32_t length);$/;"	p	signature:(queue_array_t* q, void* buff, int32_t length)
queue_array_read	src/queue-array.c	/^int32_t queue_array_read (queue_array_t* q, void* buff, int32_t length)$/;"	f	signature:(queue_array_t* q, void* buff, int32_t length)
queue_array_t	include/queue-array.h	/^} queue_array_t;$/;"	t	typeref:struct:__anon4
queue_array_write	include/queue-array.h	/^int32_t queue_array_write (queue_array_t* q, const void* buff, int32_t length);$/;"	p	signature:(queue_array_t* q, const void* buff, int32_t length)
queue_array_write	src/queue-array.c	/^int32_t queue_array_write (queue_array_t* q, const void* buff, int32_t length)$/;"	f	signature:(queue_array_t* q, const void* buff, int32_t length)
queue_link	src/queue-link.c	/^struct queue_link {$/;"	s	file:
queue_link::cond	src/queue-link.c	/^    pthread_cond_t cond;$/;"	m	struct:queue_link	file:	access:public
queue_link::head	src/queue-link.c	/^    queue_link_node_t* head;$/;"	m	struct:queue_link	file:	access:public
queue_link::idle	src/queue-link.c	/^    stack_idle_t idle;$/;"	m	struct:queue_link	file:	access:public
queue_link::mutex	src/queue-link.c	/^    pthread_mutex_t mutex;$/;"	m	struct:queue_link	file:	access:public
queue_link::tail	src/queue-link.c	/^    queue_link_node_t* tail;$/;"	m	struct:queue_link	file:	access:public
queue_link::wait	src/queue-link.c	/^    volatile uint32_t wait;$/;"	m	struct:queue_link	file:	access:public
queue_link_create	include/queue-link.h	/^queue_link_t* queue_link_create (const int32_t size);$/;"	p	signature:(const int32_t size)
queue_link_create	src/queue-link.c	/^queue_link_t* queue_link_create (const int32_t size)$/;"	f	signature:(const int32_t size)
queue_link_destroy	include/queue-link.h	/^int32_t queue_link_destroy (queue_link_t* ql);$/;"	p	signature:(queue_link_t* ql)
queue_link_destroy	src/queue-link.c	/^int32_t queue_link_destroy (queue_link_t* ql)$/;"	f	signature:(queue_link_t* ql)
queue_link_flush	include/queue-link.h	/^int32_t queue_link_flush (queue_link_t* ql);$/;"	p	signature:(queue_link_t* ql)
queue_link_flush	src/queue-link.c	/^int32_t queue_link_flush (queue_link_t* ql)$/;"	f	signature:(queue_link_t* ql)
queue_link_node	src/queue-link.c	/^typedef struct queue_link_node {$/;"	s	file:
queue_link_node::buff	src/queue-link.c	/^    void* buff;$/;"	m	struct:queue_link_node	file:	access:public
queue_link_node::next	src/queue-link.c	/^    struct queue_link_node* next;$/;"	m	struct:queue_link_node	typeref:struct:queue_link_node::queue_link_node	file:	access:public
queue_link_node_t	src/queue-link.c	/^} queue_link_node_t;$/;"	t	typeref:struct:queue_link_node	file:
queue_link_read	include/queue-link.h	/^int32_t queue_link_read (queue_link_t* ql, void* buff, const int32_t timeout);$/;"	p	signature:(queue_link_t* ql, void* buff, const int32_t timeout)
queue_link_read	src/queue-link.c	/^int32_t queue_link_read (queue_link_t* ql, void* buff, const int32_t timeout)$/;"	f	signature:(queue_link_t* ql, void* buff, const int32_t timeout)
queue_link_t	include/queue-link.h	/^typedef struct queue_link queue_link_t;$/;"	t	typeref:struct:queue_link
queue_link_write	include/queue-link.h	/^int32_t queue_link_write (queue_link_t* ql, const void* buff);$/;"	p	signature:(queue_link_t* ql, const void* buff)
queue_link_write	src/queue-link.c	/^int32_t queue_link_write (queue_link_t* ql, const void* buff)$/;"	f	signature:(queue_link_t* ql, const void* buff)
queue_list	src/queue-list.c	/^struct queue_list {$/;"	s	file:
queue_list::cond	src/queue-list.c	/^    pthread_cond_t cond;$/;"	m	struct:queue_list	file:	access:public
queue_list::head	src/queue-list.c	/^    queue_list_node_t* head;$/;"	m	struct:queue_list	file:	access:public
queue_list::mutex	src/queue-list.c	/^    pthread_mutex_t mutex;$/;"	m	struct:queue_list	file:	access:public
queue_list::tail	src/queue-list.c	/^    queue_list_node_t* tail;$/;"	m	struct:queue_list	file:	access:public
queue_list::wait	src/queue-list.c	/^    volatile uint32_t wait;$/;"	m	struct:queue_list	file:	access:public
queue_list_create	include/queue-list.h	/^queue_list_t* queue_list_create (void);$/;"	p	signature:(void)
queue_list_create	src/queue-list.c	/^queue_list_t* queue_list_create (void)$/;"	f	signature:(void)
queue_list_destroy	include/queue-list.h	/^int32_t queue_list_destroy (queue_list_t* ql);$/;"	p	signature:(queue_list_t* ql)
queue_list_destroy	src/queue-list.c	/^int32_t queue_list_destroy (queue_list_t* ql)$/;"	f	signature:(queue_list_t* ql)
queue_list_flush	include/queue-list.h	/^int32_t queue_list_flush (queue_list_t* ql);$/;"	p	signature:(queue_list_t* ql)
queue_list_flush	src/queue-list.c	/^int32_t queue_list_flush (queue_list_t* ql)$/;"	f	signature:(queue_list_t* ql)
queue_list_node	src/queue-list.c	/^typedef struct queue_list_node {$/;"	s	file:
queue_list_node::buff	src/queue-list.c	/^    void* buff;$/;"	m	struct:queue_list_node	file:	access:public
queue_list_node::next	src/queue-list.c	/^    struct queue_list_node* next;$/;"	m	struct:queue_list_node	typeref:struct:queue_list_node::queue_list_node	file:	access:public
queue_list_node::size	src/queue-list.c	/^    int32_t size;$/;"	m	struct:queue_list_node	file:	access:public
queue_list_node_t	src/queue-list.c	/^} queue_list_node_t;$/;"	t	typeref:struct:queue_list_node	file:
queue_list_read	include/queue-list.h	/^int32_t queue_list_read (queue_list_t* ql, void* buff, int32_t limit, const int32_t timeout);$/;"	p	signature:(queue_list_t* ql, void* buff, int32_t limit, const int32_t timeout)
queue_list_read	src/queue-list.c	/^int32_t queue_list_read (queue_list_t* ql, void* buff, int32_t limit, const int32_t timeout)$/;"	f	signature:(queue_list_t* ql, void* buff, int32_t limit, const int32_t timeout)
queue_list_t	include/queue-list.h	/^typedef struct queue_list queue_list_t;$/;"	t	typeref:struct:queue_list
queue_list_write	include/queue-list.h	/^int32_t queue_list_write (queue_list_t* ql, const void* buff, const int32_t size);$/;"	p	signature:(queue_list_t* ql, const void* buff, const int32_t size)
queue_list_write	src/queue-list.c	/^int32_t queue_list_write (queue_list_t* ql, const void* buff, const int32_t size)$/;"	f	signature:(queue_list_t* ql, const void* buff, const int32_t size)
rear	include/queue-array.h	/^    volatile uint32_t rear;$/;"	m	struct:__anon4	access:public
right	src/bstree.c	/^    struct bsnode* right;$/;"	m	struct:bsnode	typeref:struct:bsnode::bsnode	file:	access:public
root	src/bstree.c	/^    struct bsnode *root;$/;"	m	struct:bstree	typeref:struct:bstree::bsnode	file:	access:public
show_array	test/tmemfill.c	/^static void show_array (void)$/;"	f	file:	signature:(void)
show_queue	test/tqueue-array.c	/^static void show_queue (queue_array_t* q)$/;"	f	file:	signature:(queue_array_t* q)
size	include/queue-array.h	/^        size_t size; \/* 数据单元占用字节数 *\/$/;"	m	struct:__anon4::__anon5	access:public
size	src/bstree.c	/^    size_t size;$/;"	m	struct:bstree	file:	access:public
size	src/jitter.c	/^        size_t size;$/;"	m	struct:jitter::__anon1	file:	access:public
size	src/merge_sort.c	/^    size_t size;$/;"	m	struct:aux_data	file:	access:public
size	src/queue-link.c	/^    uint32_t size;$/;"	m	struct:__anon3	file:	access:public
size	src/queue-list.c	/^    int32_t size;$/;"	m	struct:queue_list_node	file:	access:public
spec_gettimeout	src/queue-link.c	/^static inline void spec_gettimeout (struct timespec* ts, const uint32_t timeout)$/;"	f	file:	signature:(struct timespec* ts, const uint32_t timeout)
spec_gettimeout	src/queue-list.c	/^static inline void spec_gettimeout (struct timespec* ts, const uint32_t timeout)$/;"	f	file:	signature:(struct timespec* ts, const uint32_t timeout)
stack_idle_free	src/queue-link.c	/^static inline void stack_idle_free (stack_idle_t* idle)$/;"	f	file:	signature:(stack_idle_t* idle)
stack_idle_init	src/queue-link.c	/^static inline void stack_idle_init (stack_idle_t* idle, const uint32_t size)$/;"	f	file:	signature:(stack_idle_t* idle, const uint32_t size)
stack_idle_pop	src/queue-link.c	/^static inline queue_link_node_t* stack_idle_pop (stack_idle_t* idle)$/;"	f	file:	signature:(stack_idle_t* idle)
stack_idle_push	src/queue-link.c	/^static inline void stack_idle_push (stack_idle_t* idle, queue_link_node_t* node)$/;"	f	file:	signature:(stack_idle_t* idle, queue_link_node_t* node)
stack_idle_t	src/queue-link.c	/^} stack_idle_t;$/;"	t	typeref:struct:__anon3	file:
state	src/jitter.c	/^    } state;$/;"	m	struct:jitter	typeref:enum:jitter::__anon2	file:	access:public
std	src/jitter.c	/^        uint32_t std;$/;"	m	struct:jitter::__anon1	file:	access:public
string	test/tbstree.c	/^    char string[32];$/;"	m	struct:node	file:	access:public
tail	src/queue-link.c	/^    queue_link_node_t* tail;$/;"	m	struct:queue_link	file:	access:public
tail	src/queue-list.c	/^    queue_list_node_t* tail;$/;"	m	struct:queue_list	file:	access:public
tbstree_obj	Makefile	/^tbstree_obj			= tbstree.o bstree.o$/;"	m
temp	src/merge_sort.c	/^    void* temp;$/;"	m	struct:aux_data	file:	access:public
temp	test/tqueue-list-vs-link.c	/^static int16_t temp[BUFFER_SIZE];$/;"	v	file:
tempbf	test/tqueue-link.c	/^static int16_t tempbf[BUFFER_SIZE];$/;"	v	file:
tempbf	test/tqueue-list.c	/^static int16_t tempbf[BUFFER_SIZE];$/;"	v	file:
test_insert_sort	test/tsort.c	/^static void test_insert_sort (void)$/;"	f	file:	signature:(void)
test_merge_sort	test/tsort.c	/^static void test_merge_sort (void)$/;"	f	file:	signature:(void)
test_time_insert_vs_merge_vs_qsort	test/tsort.c	/^static void test_time_insert_vs_merge_vs_qsort (void)$/;"	f	file:	signature:(void)
tforeach_obj	Makefile	/^tforeach_obj 		= tforeach.o$/;"	m
thread_insert	test/tbstree.c	/^static void* thread_insert (void* args)$/;"	f	file:	signature:(void* args)
thread_read	test/tjitter.c	/^void* thread_read (void* args)$/;"	f	signature:(void* args)
thread_read	test/tjitter.c	/^void* thread_read (void* args);$/;"	p	file:	signature:(void* args)
thread_read	test/tqueue-array.c	/^void* thread_read (void* args)$/;"	f	signature:(void* args)
thread_send	test/tqueue-link.c	/^static void* thread_send (void* args)$/;"	f	file:	signature:(void* args)
thread_send	test/tqueue-link.c	/^static void* thread_send (void*);$/;"	p	file:	signature:(void*)
thread_send	test/tqueue-list.c	/^static void* thread_send (void* args)$/;"	f	file:	signature:(void* args)
thread_send	test/tqueue-list.c	/^static void* thread_send (void*);$/;"	p	file:	signature:(void*)
time_diff	test/tsort.c	/^static uint64_t time_diff (struct timeval* b, struct timeval* e)$/;"	f	file:	signature:(struct timeval* b, struct timeval* e)
tjitter_obj	Makefile	/^tjitter_obj			= memfill.o queue-array.o jitter.o tjitter.o$/;"	m
tmemfill_obj	Makefile	/^tmemfill_obj 		= memfill.o tmemfill.o$/;"	m
top	src/queue-link.c	/^    queue_link_node_t* top;$/;"	m	struct:__anon3	file:	access:public
tqueue_array_obj	Makefile	/^tqueue_array_obj 	= memfill.o queue-array.o tqueue-array.o$/;"	m
tqueue_link_obj	Makefile	/^tqueue_link_obj 	= queue-link.o tqueue-link.o$/;"	m
tqueue_list_obj	Makefile	/^tqueue_list_obj		= queue-list.o tqueue-list.o$/;"	m
tqueue_list_vs_link_obj	Makefile	/^tqueue_list_vs_link_obj = queue-list.o queue-link.o tqueue-list-vs-link.o$/;"	m
unit	src/jitter.c	/^        uint32_t unit;$/;"	m	struct:jitter::__anon1	file:	access:public
wait	src/queue-link.c	/^    volatile uint32_t wait;$/;"	m	struct:queue_link	file:	access:public
wait	src/queue-list.c	/^    volatile uint32_t wait;$/;"	m	struct:queue_list	file:	access:public
x	test/tmemfill.c	/^    int x;$/;"	m	struct:data	file:	access:public
y	test/tmemfill.c	/^    int y;$/;"	m	struct:data	file:	access:public
